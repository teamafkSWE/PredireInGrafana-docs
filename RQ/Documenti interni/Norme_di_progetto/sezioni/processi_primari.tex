\section{Processi primari}
	\subsection{Fornitura}
		\subsubsection{Scopo}
		Lo scopo del processo di fornitura consiste nelle attività e compiti dell'acquirente, come risposta ai bisogni del cliente in ambito di sistema, prodotto e/o servizio software. Nello specifico, le caratteristiche richieste dal proponente sono analizzate e stilate nello \textit{Studio di Fattibilità}, il quale è alla base del processo di fornitura. Dopodiché è possibile stabilire le risorse e le procedure necessarie alla redazione di un \textit{Piano di Progetto} da seguire fino alla consegna del materiale prodotto.
		Nel dettaglio le attività svolte da questo processo sono:
		\begin{itemize}
			\item avvio;
			\item studio di fattibilità;
			\item contrattazione;
			\item progettazione;
			\item esecuzione e controllo;
			\item revisione e valutazione;
			\item consegna e completamento.
		\end{itemize}
		\subsubsection{Aspettative}
		Il gruppo deve avere un frequente contatto con il cliente al fine di rispettare i vincoli obbligatori da lui fissati, onde evitare di scostarsi troppo dal prodotto finale richiesto. Per questo è necessario comunicare con il proponente, per poter aver chiari i bisogni che tale prodotto intende soddisfare con le sue funzionalità. Quindi, ogniqualvolta il gruppo venga a contatto con il proponente, deve stabilire:
		\begin{itemize}
			\item aspetti chiave che soddisfano i bisogni richiesti;
			\item requisiti e vincoli dei processi;
			\item verifica continua;
			\item chiarimento di eventuali dubbi;
			\item accordo sulla qualifica del prodotto.
			\end{itemize} 
		\subsubsection{Descrizione}
		Questa sezione ha il compito di mostrare le norme che il \textit{TeamAFK} adotterà in tutte le attività di progettazione, sviluppo e consegna del prodotto \textit{Predire in Grafana}, con lo scopo di diventare i fornitori del capitolato proposto dalla proponente \textit{Zucchetti SPA} e dai committenti Prof. Tullio Vardanega e Prof. Riccardo Cardin.
		\subsubsection{Attività}
			\paragraph{Avvio}
			\paragraph*{Studio di Fattibilità} \mbox{} \\ \mbox{} \\
			Lo \textit{Studio di Fattibilità}, redatto per ogni capitolato\glo dagli analisti, illustra:
			\begin{itemize}
				\item \textbf{Descrizione generale}: sintesi delle informazioni generali del capitolato e delle circostanze da cui sorgono tali richieste;
				\item \textbf{Obiettivi}: vengono mostrate le caratteristiche principali del prodotto ed i relativi obiettivi da raggiungere;
				\item \textbf{Tecnologie utilizzate}: corrisponde all'elenco degli strumenti messi a disposizione dall'azienda proponente al team per sviluppare il progetto;
				\item \textbf{Valutazione finale}: si tratta di un commento elaborato dal gruppo una volta riunitosi e analizzato le  richieste dell'azienda, motivando la scelta di focalizzarsi o meno su una determinata offerta.
			\end{itemize}
			\paragraph{Contrattazione} \mbox{} \\ \mbox{} \\
			L'attività di contrattazione prevede la discussione dei termini di sviluppo del progetto sia per quanto concerne l'aspetto economico, sia per quanto riguarda l'aspetto dei requisiti che il prodotto finale deve rispettare. Come base di discussione il \textit{TeamAFK} propone il preventivo all'interno del \textit{Piano di Progetto} e la lista dei requisiti esposti all'interno dell'\textit{Analisi dei Requisiti}. Il gruppo si impegna ad aggiornare tali
valutazioni proposte sulla base dei feedback e della discussione con il committente.
			\paragraph{Progettazione} \mbox{} \\ \mbox{} \\
			L'attività di progettazione prevede la redazione di un \textit{Piano di Progetto} che definisca le linee guida per la gestione e la realizzazione del progetto e che garantisca il raggiungimento degli obiettivi entro i termini prefissati.	
			
			\paragraph*{Coinvolgimento di committente e proponente}	\mbox{} \\ \mbox{} \\
			Il \textit{TeamAFK} prevede di coinvolgere il proponente Gregorio Piccoli - \textit{Zucchetti SpA} nell'analisi dei requisiti e nello sviluppo del progetto tramite incontri su appuntamento. Il coinvolgimento del committente è invece garantito dalla presenza di revisioni periodiche, come previsto dalle regole di progetto.		
			
			\paragraph*{Piano di Progetto} \mbox{} \\ \mbox{} \\
			Il \textit{Piano di Progetto} è un documento redatto dal project manager\glo e dagli amministratori; si aggiunge all'insieme dei documenti che il team dovrà seguire per tutta la durata del progetto. In particolare questo documento conterrà:
			\begin{itemize}
				\item \textbf{Analisi dei rischi}: il \textit{Responsabile} analizza tutti gli eventuali rischi di tipo tecnico, economico e temporale che possono presentarsi durante il progetto, fornendo anche soluzioni che possano risolverli o almeno limitare i loro effetti negativi;
				\item \textbf{Modello di sviluppo}: viene definita la struttura su cui basarsi per la pianificazione, esecuzione e consegna del prodotto software;
				\item \textbf{Pianificazione}: viene pianificato l'insieme delle attività da seguire durante le fasi di progetto, collocandole nel tempo e stabilendo le loro scadenze;
				\item \textbf{Preventivo e consuntivo}: con il preventivo viene mostrata una stima di quello che sarà il carico di lavoro che il team sosterrà durante il progetto, in termini di tempo e i relativi costi. Con il consuntivo di periodo, invece verranno riportati le variazioni dei costi rispetto a quanto preventivato.
			\end{itemize}
			\paragraph{Esecuzione e controllo} \mbox{} \\ \mbox{} \\
Il fornitore deve attuare ed eseguire i piani sviluppati nella fase di pianificazione e sviluppare il prodotto software monitorando il progresso e la qualità.
			\paragraph*{Piano di Qualifica} \mbox{} \\ \mbox{} \\
			I verificatori si occuperanno di redigere il \textit{Piano di Qualifica}, ovvero l'insieme di attività con il compito di fissare obiettivi di qualità del prodotto nel suo complesso. Verranno quindi considerati anche i processi e le risorse necessarie a raggiungere tali obiettivi. Nel dettaglio il \textit{Piano di Qualifica} si focalizza su:
			\begin{itemize}
				\item \textbf{Qualità di prodotto}: vengono fissate le politiche per il raggiungimento della qualità, gli obiettivi da raggiungere e gli strumenti necessari al controllo;
				\item \textbf{Qualità di processo}: stabilire sulla base di opportune misurazioni il grado di efficacia ed efficienza di un processo a partire dalla sua definizione;
				\item \textbf{Valutazione di miglioramento}: i problemi e le relative soluzioni vengono evidenziate in questa sezione del \textit{Piano di Qualifica};
				\item \textbf{Resoconto dell'attività di verifica}: vengono riportate i risultati delle metriche come resoconto dell'attività di qualifica.
			\end{itemize}
			
			\paragraph*{Standard di qualità} \mbox{} \\ \mbox{} \\
			La sezione \S \hyperref[sez:standardQualita]{A} descrive gli standard di qualità di riferimento per lo sviluppo della qualità del progetto.
			
			\paragraph{Revisione e valutazione} \mbox{} \\ \mbox{} \\
			Il fornitore deve eseguire la verifica e validazione al fine di dimostrare che il prodotto software soddisfi i requisiti descritti nell'\textit{Analisi dei Requisiti}.
			\paragraph{Consegna e completamento} \mbox{} \\ \mbox{} \\		
			Il fornitore consegna il prodotto software come specificato dal contratto.
		\subsubsection{Metriche di qualità}
		Per questo processo non sono state definite metriche di qualità specifiche.
		\subsubsection{Strumenti di supporto}
		Di seguito sono illustrati gli strumenti utilizzati per l'avvio dell'attività di fornitura.
		\begin{itemize}
			\item \textbf{GanttProject}: software per la produzione di diagrammi di Gantt\glo (analizzato nel dettaglio in § 3.8.3);
			\item \textbf{Google Calendar}: sistema di calendari gestito da Google.
		\end{itemize}

	\subsection{Sviluppo}
		\subsubsection{Scopo}È il processo che si occupa di stabilire le attività da svolgere per costruire e consegnare il prodotto finale.
		\subsubsection{Aspettative}
		Le aspettative sono le seguenti:
			\begin{itemize}
				\item stabilire obiettivi di sviluppo;
				\item stabilire vincoli tecnici;
				\item stabilire vincoli di design;
				\item realizzare il prodotto software che superi i test, e soddisfi i vincoli di progetto.
			\end{itemize}
		\subsubsection{Descrizione}
			Il processo di sviluppo si divide in:
				\begin{itemize}
					\item analisi dei requisiti;
					\item progettazione;
					\item codifica.
				\end{itemize}
		\subsubsection{Attività}
			\paragraph{Analisi dei Requisiti} \mbox{} \\ \mbox{} \\
			L'elenco dei requisiti necessari allo svolgimento del processo di sviluppo viene raccolto e redatto dagli analisti in un apposito documento di \textit{Analisi dei Requisiti}. Quest'ultimo ha lo scopo di:
				\begin{itemize}
					\item descrivere l'obiettivo del prodotto;
					\item fornire ai progettisti riferimenti precisi ed affidabili;
					\item stabilire le prospettive e le funzionalità del prodotto in base ai vincoli fissati dal proponente;
					\item fornire ai verificatori riferimenti affidabili per la loro attività di controllo;
					\item valutare rischi, costi e benefici in relazione al carico di lavoro.
				\end{itemize} 
			\subparagraph{Aspettative} \mbox{} \\ \mbox{} \\
			L'obiettivo di questa attività è redigere un documento formale contenente tutti i requisiti richiesti dal progetto.
			\subparagraph{Descrizione} \mbox{} \\ \mbox{} \\
			I requisiti saranno raccolti nel seguente modo:
				\begin{itemize} 
					\item lettura del capitolato d'appalto;
					\item confronto con il proponente;
					\item discussione tra i componenti del gruppo;
					\item studio dei casi d'uso.
				\end{itemize}
				\subparagraph{Casi d'uso} \mbox{} \\ \mbox{} \\
				I casi d'uso sono scenari che descrivono una possibile sequenza di iterazioni dell'utente, visto come attore\glo attivo e/o passivo, e il sistema. La struttura di un caso d'uso è la seguente:
				\begin{itemize}
					\item codice identificativo;
					\item titolo;
					\item diagramma UML\glo (se presente);
					\item attore primario;
					\item precondizioni;
					\item postcondizioni;
					\item scenario principale;
					\item inclusioni (se presenti);
					\item estensioni (se presenti).

				\end{itemize}
				\subparagraph*{Codice identificativo dei casi d'uso} \mbox{} \\ \mbox{} \\
			Il codice di ogni caso d'uso seguirà questo formalismo: \\ \\
			\centerline{\textbf{UC[codice\_padre].[codice\_figlio]}} \\ \\
			\textbf{Requisiti} \\ \\
			I requisiti seguiranno la seguente struttura:
				\begin{itemize}
					\item \textbf{codice identificativo}: è un codice univoco e conforme alla codifica: \\ \\
					\centerline{\textbf{Re[Importanza][Tipologia][Codice]}} \\ \\
					Le voci riportate nella precedente codifica significano: 
					\begin{itemize}
						\item \textbf{Importanza}: la quale può assumere come valori:
						\begin{itemize}
							\item 1: requisito obbligatorio, irrinunciabile;
							\item 2: requisito desiderabile, perciò non obbligatorio ma riconoscibile;
							\item 3: requisito opzionale, ovvero trattabile in un secondo momento o relativamente utile.
						\end{itemize}
						\item \textbf{Tipologia}: la quale può assumere come valori:
						\begin{itemize}
							\item F: requisito funzionale;
							\item P: requisito prestazionale;
							\item Q: requisito di qualità;
							\item V: requisito di vincolo.
						\end{itemize}
						\item \textbf{Codice identificativo}: il quale è un identificatore univoco del requisito, e viene espresso in forma gerarchica padre/figlio.
					\end{itemize}
					\item \textbf{Classificazione}: specifica il peso del requisito facilitando la sua lettura anche se causa ridondanza;
					\item \textbf{Descrizione}: sintesi completa di un requisito;
					\item \textbf{Fonti}: il requisito può avere le seguenti provenienze:
					\begin{itemize}
						\item capitolato;
						\item interno: requisito che gli analisti ritengono di aggiungere in base alle esigenze del team;
						\item caso d'uso: il requisito proviene da uno o più casi d'uso, dei quali è necessario riportare il codice univoco di caso d'uso;
						\item verbale: dopo un chiarimento da parte del proponente è possibile che sorga un requisito non preventivato. E le informazioni su di esso sono riportate e tracciati nei rispettivi verbali.
					\end{itemize}
				\end{itemize} 
				\subparagraph*{UML} \mbox{} \\ \mbox{} \\
				I diagrammi UML servono per descrivere un caso d'uso. Gli analisti dovranno utilizzare la versione v.2.0.
				\pagebreak
	\paragraph{Progettazione}
			\subparagraph{Scopo} \mbox{} \\ \mbox{} \\
		Il processo di progettazione ha il compito di stabilire le migliori operazioni da effettuare per fornire una soluzione soddisfacente per tutti gli stakeholders\glo. Per fare ciò è necessario identificare la struttura complessiva del sistema, per poi suddividerla nei moduli e unità architetturali che la compongono. In questo modo è più semplice per i programmatori che implementeranno il sistema, comprendere e rispettare i requisiti funzionali.
			A questo scopo si deve:
			\begin{itemize}
			\item tradurre i requisiti in unità di codice (i moduli);
			\item assegnare ai programmatori singoli compiti;
			\item fornire un prototipo di sistema da migliorare, ma funzionante;
			\item garantire il tracciamento dei requisiti per componente.
			\end{itemize}
			Strategie adottate:
			\begin{itemize}			
			\item suddivisione della macro-architettura;
			\item implementazione dei moduli.
			\end{itemize}

		\subparagraph{Descrizione} \mbox{} \\ \mbox{} \\
		Il \textit{TeamAFK} adotta un approccio \textbf{agile} allo sviluppo del prodotto software, lasciando immutate le esigenze di documentazione correlata con la gestione dell'avanzamento di progetto e le verifiche di qualità. \\
		Lo svilppo dell'architettura software si suddivide in due momenti specifici:
			\begin{itemize}
				\item \textbf{Technology baseline}: mostra ad alto livello le specifiche di progettazione del prodotto e le sue componenti, elencando i diagrammi UML utilizzati per descrivere l'architettura del prodotto. Viene realizzata una Proof of Concept\glo del prodotto;
				\item \textbf{Product baseline}: parte incrementale del prodotto finale da cui continuare a lavorare, integrando le specifiche riportate nella Tecnology Baseline e definendo anche i test necessari alla verifica. Viene presentata tramite diagrammi delle classi e di sequenza. L'analisi è comprensiva di design pattern contestualizzati all'architettura.
			\end{itemize} 
			\subparagraph*{Technology Baseline} \mbox{} \\ \mbox{} \\
			Il progettista incaricato, si occuperà di includere:
			\begin{itemize}
				\item \textbf{Diagrammi UML}: utilizzati per rappresentare i casi d'uso descritti nell'\textit{Analisi dei Requisiti};
				\item \textbf{Tecnologie utilizzate}: vengono mostrate le tecnologie impiegate, mostrando le loro funzionalità, pregi e difetti;
				\item \textbf{Proof of Concept (POC)}: implementazione di un PoC che utilizzi e dimostri la fattibilità delle tecnologie che utilizziamo per implementare il prodotto software;
				\item \textbf{Tracciamento delle componenti}: viene mostrata la relazione tra il componente e il requisito che intende rispettare; 
				\item \textbf{Test di integrazione}: sono operazioni che si occupano di verificare l'unione tra le parti, in base alle rispettive interfacce.
			\end{itemize}
			\subparagraph*{Proof of Concept} \mbox{} \\ \mbox{} \\
			Il \textit{TeamAFK} ha deciso di implementare un PoC in modo incrementale. Perciò, in accordo con il proponente, vengono selezionati degli incrementi da sviluppare con l’intenzione di esplorare tutte le tecnologie che devono essere utilizzate nel prodotto finale. Queste tecnologie sono: \begin{itemize}
			\item Node.js;
			\item React;
			\item SVM;
			\item JavaScript;
			\item TypeScript;
			\item JSON;
			\item HTML5;
			\item CSS3;
			\item Grafana;
			\item Chart.js.
\end{itemize}
			\subparagraph*{Product Baseline} \mbox{} \\ \mbox{} \\
			Gli aspetti su cui la  Product baseline si sofferma sono:
				\begin{itemize}
					\item \textbf{Definizione delle classi}: ogni classe deve essere descritta, specificando scopo e funzionalità;
					\item \textbf{Tracciamento delle classi}: ovvero identificare il requisito a cui si lega una classe;
					\item \textbf{Diagrammi UML}: per rendere più chiare e complete le scelte progettuali adottate, vengono utilizzati dei diagrammi UML usando la
versione 2.0 del linguaggio. Ogni diagramma deve essere seguito dalla
descrizione di ciò che rappresenta. I diagrammi UML utilizzati per presentare l'architettura sono i seguenti:
					\begin{itemize}
					\item \textbf{Diagramma delle classi}: i diagrammi delle classi descrivono in modo dettagliato gli oggetti che utilizziamo e le dipendenze che sussistono tra di loro;
					\item \textbf{Diagramma dei package}: con i diagrammi dei package raggruppiamo ad alto livello i macro insiemi delle nostre componenti, suddividendole in package. Questi ultimi infatti individuano uno spazio dei nomi che tra loro non presentano alcuna ambiguità. Inoltre, grazie ai diagrammi dei package, definiamo le dipendenze ad alto livello tra le componenti; ciò è molto utile per comprendere la complessità strutturale ed il flusso delle dipendenze stesse. Permettono infatti di individuare circolarità ed elevata complessità delle dipendenze in modo immediato;
					\item \textbf{Diagramma di attività}: i diagrammi di attività permettono di descrivere un processo attraverso dei grafi, in cui i nodi rappresentano le attività e gli archi l'ordine con cui vengono eseguite;
					\item \textbf{Diagramma di sequenza}: i diagrammi di sequenza descrivono la collaborazione di un gruppo di oggetti che devono implementare collettivamente un comportamento, nello scorrere del tempo.
				\end{itemize}
					\item \textbf{Design pattern}\glo : sono esposti i design pattern adottati per rappresentare l'architettura del prodotto. Tutti i design pattern devono essere accompagnati da un diagramma e una descrizione delle sue caratteristiche;
					\item \textbf{Test di integrazione}: test necessari per verificare che l’unione delle parti funzioni correttamente;
					\item \textbf{Test di unità}: ovvero verificare le funzionalità della sola classe, senza metterla in relazione con altre componenti del sistema.
				\end{itemize}
				\subparagraph{Qualità dell'architettura} \mbox{} \\ \mbox{} \\
				In seguito alla specifica dei requisiti che consolida le funzionalità richieste, viene realizzata l'architettura del sistema. Tale architettura deve perseguire le seguenti caratteristiche: \begin{itemize}
				\item appropriatezza: l'architettura soddisfa tutti i requisiti;
				\item modularità: l'architettura è suddivisa in parti ben distinte;
				\item robustezza: l'architettura può sopportare diversi ingressi dall'utente e dall'ambiente;
				\item affidabilità: l'architettura garantisce una buona usabilità del prodotto quando viene implementata;
				\item manutenibilità: l'architettura può subire modifiche a costi contenuti.
				\end{itemize}
				In particolare, riguardo alla modularità, il progettista deve scomporre il sistema in moduli, fornendo una descrizione precisa della struttura modulare e delle relazioni che esistono tra essi.
Questo porta ai seguenti vantaggi: \begin{itemize}
\item maggiore leggibilità e riusabilità del codice;
\item semplificazione dell'individuazione e della correzione degli errori;
\item realizzazione di prototipi (in relazione al modello di sviluppo adottato).
\end{itemize}
Per perseguire le qualità sopra elencate, è richiesta l'implementazione di design pattern ove necessario.\\
Al fine di implementare le qualità dell'architettura appena descritte, ai progettisti viene richiesto di seguire le seguenti regole: \begin{itemize}
\item evitare package vuoti, classi e parametri non utilizzati e parametri senza tipo;
\item evitare la presenza di dipendenze circolari;
\item evitare modifiche ad eventuali librerie esterne utilizzate;
\item utilizzare nomi significativi per le classi e i metodi in esse contenuti, in modo da facilitare la comprensione immediata di ogni componente.
\end{itemize}
	\paragraph{Codifica}
		\subparagraph*{Scopo}\mbox{} \\ \mbox{} \\
		Lo scopo del processo di codifica è implementare il prodotto software richiesto. Il programmatore è colui che ha il compito di attuare i design pattern e non può agire diversamente.
		\subparagraph*{Aspettative}\mbox{} \\ \mbox{} \\
		L'obiettivo di questo processo è la costruzione del prodotto richiesto secondo le specifiche richieste dal proponente. Perciò il programmatore deve attenersi alle norme qui stabilite, al fine di produrre un codice solido e uniforme, facilitando l'attivita di manutenzione, verifica, validazione e miglioramento della qualità del prodotto.
		\subparagraph*{Descrizione}\mbox{} \\ \mbox{} \\
		Il codice deve attenersi alle norme e rispettare i requisiti di qualità, espressi nel documento \textit{Piano di Qualifica}, per garantirne la qualità desiderata.
		\subsubparagraph*{Stile di codifica} \mbox{} \\ \mbox{} \\
		Lo stile di codifica stabilisce le norme che il programmatore deve rispettare, focalizzandosi nei seguenti ambiti:
		\begin{itemize}
			\item \textbf{Indentazione}: blocchi di codice innestato deve avere per ogni livello di indentazione quattro spazi, ad eccezione dei commenti. È consigliato impostare adeguatamente la configurazione dell'IDE\glo usato:
\begin{lstlisting}
function() {
   let x = 0;
}
\end{lstlisting}
			\item \textbf{Parentesizzazione}: si richiede di aprire le parentesi in linea e non al di sotto dei costrutti a cui si riferiscono:
			\begin{lstlisting}
class Example {
   // TO-DO
}
\end{lstlisting}
			\item \textbf{Scrittura dei metodi}: è desiderabile la poca prolissità del codice di un metodo;
			\item \textbf{Spaziatura tra operandi}: prima e dopo ciascun operando vanno
inseriti degli spazi al fine di rendere più ordinato e leggibile il codice.
Segue un esempio di tale pratica:
\begin{lstlisting}
// OK
let myVar1 = 1;
let myVar2 = 2;
let myVar3 = myVar1 + myVar2;
\end{lstlisting}
			\item \textbf{Spaziatura del codice}: tra i costrutti di codice è obbligatorio lasciare una riga vuota per rendere più ordinato e leggibile il codice. Segue un esempio di tale pratica:
			\begin{lstlisting}
// OK!
function() {
//TODO
}

myMethod() {
//TODO
}			\end{lstlisting}
			\item \textbf{Dichiarazione variabili}: è sconsigliata la dichiarazione di variabili in linea a favore dell’ordine e della leggibilità del codice. Segue un esempio esplicativo: 
			\begin{lstlisting}
// NO
let x = 1, y = 2;
// OK
let x = 1;
let y = 2;
			\end{lstlisting}
			\item \textbf{Univocità dei nomi}: per evitare ambiguità e incomprensioni, tutti i nomi di classi, metodi, funzioni ed interfacce, devono essere univoci ed esplicativi;
			\item \textbf{Classi}: i nomi delle classi devono iniziare con la lettera maiuscola:
\begin{lstlisting}
class Example {
   // TO-DO
}
\end{lstlisting}
			\item \textbf{Costanti}: i nomi delle costanti devono essere scritte con lettere maiuscola:
\begin{lstlisting}
const CONSTANT_VALUE = "This is a constant value";
\end{lstlisting}
			\item \textbf{Metodi}: i nomi dei metodi devono iniziare con la lettera minuscola, seguita da lettere minuscole. Nel caso di nomi composti da più parole, tutte quelle che seguono la prima iniziano con la prima lettera maiuscola a cui seguono lettere minuscole. Viene così rispettato il modello \textit{CamelCase}\glo:
\begin{lstlisting}
class MyClass {
   exampleMethod() {
      //...
   }
}
\end{lstlisting}
			\item \textbf{Variabili}:il nome di ciascuna variabile deve iniziare con una lettera minuscola. Nelle varibili con nome composto, la prima parola
avrà la prima lettera minuscola, mentre le seguenti avranno la
prima lettera maiuscola, come indicato dalla pratica del \textit{CamelCase}.
Segue un esempio della corretta implementazione di suddetta pratica:
\begin{lstlisting}
let varExample = 0;
\end{lstlisting}
			\item \textbf{Commenti}: i commenti nel codice devono essere concisi ma sufficientemente descrittivi. Essi precedono l’implementazione di metodi e classi
descrivendo brevemente la loro funzione. Sono possibili due tipi di commenti: in linea tramite l’utilizzo del doppio slash (\texttt{//}) o a blocco tramite la costruzione \texttt{//**...*/}. Un esempio è il seguente:
\begin{lstlisting}
//** This is a comment class example.
* OK!
*/
class myClass {
   // This is a test method.
   myMethod() {
      let myVar = 0; 
      if (condition) {
         //TO-DO
      } else {
         //TO-DO
      }
   }
}
\end{lstlisting}
			\item \textbf{Lingua}: codice e commenti devono essere espressi in lingua inglese.
		\end{itemize}
		\subsubparagraph*{Ricorsione} \mbox{} \\ \mbox{} \\
		La ricorsione deve essere il più possibile evitata, perché è causa di un aumento di complessità della soluzione ad un problema. Per questo è preferibile adottare soluzioni iterative.
	\subsubsection{Metriche di qualità}
			\paragraph{Documenti}\mbox{} \\ \mbox{} \\
			Le metriche utilizzate per determinare la qualità e leggibilità dei documenti sono descritte di seguito:
			 \begin{itemize}
			\item \textbf{Indice di Gulpease}: indice di leggibilità di un testo tarato sulla lingua italiana e basato su due variabili linguistiche: la lunghezza della parola e la lunghezza della frase rispetto al numero delle lettere;
			\item \textbf{Indice Fog}: misura la lunghezza media delle parole e delle frasi nei documenti. Quanto più è alto il valore dell'indice Fog, tanto più è difficile capire il documento.
			\end{itemize}
			Una loro descrizione più accurata la si trova nella sezione \S \hyperref[par:metricheDoc]{3.1.5}.
			\subparagraph*{Analisi dei Requisiti} \mbox{} \\ \mbox{} \\
			Durante il periodo di analisi vengono identificati i requisiti del progetto e definiti i relativi casi d'uso. 
			Gli obiettivi sono:
			\begin{itemize}
			\item  formulare la definizione di casi d'uso e requisiti;
			\item ottenere la loro approvazione;
			\item tracciare il loro cambiamento nel tempo.
			\end{itemize}
			La strategia prevede:
			\begin{itemize}
			\item considerare lo scopo del progetto e le richieste degli stakeholder;
			\item esprimere ciò in forma di requisiti, classificati in obbligatori, desiderabili e opzionali;
			\item valutare il corpo dei requisiti e negoziare cambiamenti se necessario;
			\item ottenere la loro approvazione da parte del proponente.
			\end{itemize}
			Le metrice utilizzate per la verifica della qualità dei requisiti sono: \begin{itemize}
			\item \textbf{MG02 - PROS};
			\item \textbf{MG03 - PRDS}.
\end{itemize}			 
Quest'ultime sono descritte nella sezione \S \hyperref[par:metricheGen]{3.3.5}.
			\paragraph{Progettazione}\mbox{} \\ \mbox{} \\
			Questo paragrafo elenca le metriche a cui l'architettura software viene sottoposta per valutarne la qualità.
   \begin{longtable}{ C{4.5cm} c L{9.5cm} }
	\rowcolor{white}\caption{Metriche per la qualità dell'architettura software}\\
		\rowcolor{redafk}
		\textcolor{white}{\textbf{Nome}} & \textcolor{white}{\textbf{Codice}} & \centerline{\textcolor{white}{\textbf{Descrizione}}} \\
		\endfirsthead
		\rowcolor{white}\caption[]{(continua)} \\
		\rowcolor{redafk}
		\textcolor{white}{\textbf{Nome}} & \textcolor{white}{\textbf{Codice}} & \centerline{\textcolor{white}{\textbf{Descrizione}}} \\
		\endhead
		Fan-In & MS05 & Misura il numero di funzioni o di metodi che chiamano una funzione o un metodo X. Un alto valore implica che X è strettamente collegata al resto del progetto e che eventuali modifiche di X produrranno ampi effetti a catena.\\
		Fan-Out & MS06 & Misura il numero di funzioni che sono chiamate dalla funzione X. Un alto valore indica che la complessità generale di X può essere alta a causa della complessità della logica di controllo necessaria per coordinare i componenti chiamati.\\
	\end{longtable}
	\begin{comment}
			\begin{itemize}
						\item \textbf{Fan-In}: misura il numero di funzioni o di metodi che chiamano una funzione o un metodo X. Un alto valore implica che X è strettamente collegata al resto del progetto e che eventuali modifiche di X produrranno ampi effetti a catena;
		\item \textbf{Fan-Out}: misura il numero di funzioni che sono chiamate dalla funzione X. Un alto valore indica che la complessità generale di X può essere alta a causa della complessità della logica di controllo necessaria per coordinare i componenti chiamati.
			\end{itemize}
			\end{comment}
			\paragraph{Codifica} \mbox{} \\ \mbox{} \\
			Questo paragrafo elenca le metriche a cui il prodotto software viene sottoposto per misurarne la qualità.
			I valori riportati sono una dichiarazione di intenti; nulla vieta che in corso d'opera possano avvenire delle revisioni.
			\begin{longtable}{ C{4.5cm} c L{9.5cm} }
	\rowcolor{white}\caption{Metriche del software}\\
		\rowcolor{redafk}
		\textcolor{white}{\textbf{Nome}} & \textcolor{white}{\textbf{Codice}} & \centerline{\textcolor{white}{\textbf{Descrizione}}} \\
		\endfirsthead
		\rowcolor{white}\caption[]{(continua)} \\
		\rowcolor{redafk}
		\textcolor{white}{\textbf{Nome}} & \textcolor{white}{\textbf{Codice}} & \centerline{\textcolor{white}{\textbf{Descrizione}}} \\
		\endhead
		\label{par:MS01}Linee di Codice (LOC) & MS01 & Rappresenta  le  dimensioni  del  codice di un metodo. È espresso in termini di numero di linee di codice, ed è utilizzato per dimensionare la produttività delle persone e da questa lo sforzo richiesto per sviluppare tale funzione. \\
		Numero di Metodi (NM)  & MS02 & Numero medio di metodi contenuti nelle classi di un oggetto. Un numero troppo alto di metodi può indicare la necessità di scomporre la classe. Un numero troppo basso deve far riflettere sull'effettiva utilità della classe in esame. 
		\[ NM =\frac{\sum\#metodi}{\#classi}  \] \\
		Numero di Parametri (NP) & MS03 & Numero medio di parametri passati ad un metodo. Un eccessivo numero di parametri passati ad un metodo può
indicare un'eccessiva complessità dello stesso.
\[ NP =\frac{\#metodi}{\#parametri\_passati}  \] \\
		Commenti per Linee di \newline Codice (CLC) & MS04 & Rapporto fra numero di righe di commento e numero totale di righe (vuote escluse). Un codice ben commentato può essere compreso più facilmente e velocemente, facilitando le operazioni di manutenzione. 
		\[ CLC = \frac{\#righe\_commento}{\#tot\_righe}\] \\
	\end{longtable}
	\begin{comment}
			\begin{itemize}
			\item \textbf{Linee di Codice}: è la metrica che registra la dimensione di tutto il codice sorgente di un metodo;
			\item \textbf{Numero dei Metodi}: questa metrica conta il numero di metodi presenti in un oggetto. Questo strumento permette di determinare la necessità di modularizzare un oggetto;
			\item \textbf{Numero di Parametri}: un numero elevato di parametri di un metodo comporta ad un alto grado di complessità del problema;
			\item \textbf{Commenti per Linee di Codice}: questa metrica calcola il rapporto tra le linee di commento e quelle di codice effettivo. Permette quindi di stabilire il livello di comprensibilità del codice sorgente da parte del programmatore, visto che un codice commentato risulta più comprensibile di quello sprovvisto di commento o con note superficiali.
			\end{itemize}
			Vengono inoltre definite le seguenti metriche per valutare la qualità dei test effettuati: \begin{itemize}
			\item \textbf{Code Coverage}: indica la percentuale di righe di codice percorse durante il test sulle righe totali durante la loro esecuzione;
			\item \textbf{Passed Test Cases Percentage}: indica la percentuale
di test superati sul totale dei test eseguiti. Un'alta percentuale di superamento
indica la tendenza del codice ad essere già corretto prima dei test;
			\item \textbf{Failed Test Cases Percentage}: indica la percentuale
di test falliti sul totale dei test eseguiti. Un'alta percentuale di fallimento indica la tendenza alla scorrettezza del codice.
			\end{itemize}
			\end{comment}
			\pagebreak
	\subsubsection{Strumenti di supporto}
	\paragraph{Browser}\mbox{} \\ \mbox{} \\
	Per provare e verificare il funzionamento del nostro tool e plug-in usiamo i seguenti broswer: \begin{itemize}
	\item \textbf{Google Chrome}: versione 58 o successiva;
	\item \textbf{Internet Explorer}: versione 11;
	\item \textbf{Microsoft Edge}: versione 14 o successiva;
	\item \textbf{Mozilla Firefox}: versione 54 o successiva;
	\item \textbf{Safari}: versione 10 o successiva..
	\end{itemize}
	\paragraph{Coveralls}\mbox{} \\ \mbox{} \\
	Servizio web utilizzato per tenere traccia della copertura del codice.\\
	\centerline{\url{https://coveralls.io/}}
	\paragraph{Draw.io}\mbox{} \\ \mbox{} \\
	Programma utilizzato per la creazione di diagrammi UML.\\
	\centerline{\url{https://app.diagrams.net/}}
	\paragraph{ESLint}\mbox{} \\ \mbox{} \\
	È un plugin\glo utilizzato per effettuare analisi statica del codice e rilevare problematiche nei pattern codificati in linguaggio JavaScript\glo. \\
	\centerline{\url{https://eslint.org/}}
	\paragraph{Grafana}	\mbox{} \\ \mbox{} \\
	Software di analisi open source utilizzato per visualizzare e monitorare i dati attraverso grafici e avvisi. Grafana viene fornito con un plug-in per InfluxDB. Quest'ultimo include un editor di query personalizzato e supporta annotazioni e modelli di query.\\
	\centerline{\url{https://grafana.com/}}
	\paragraph{InfluxDB}\mbox{} \\ \mbox{} \\
	Database\glo di serie temporali open source utilizzato per la gestione e l'aggiornamento dei dati.\\
	\centerline{\url{https://www.influxdata.com/}}
	\paragraph{IntelliJ IDEA}\mbox{} \\ \mbox{} \\
	IDE\glo utilizzato per la codifica in JavaScript, garantendo la piena compatibilità con i sistemi operativi Linux, Windows e MacOS.\\
	\centerline{\url{https://www.jetbrains.com/idea/}}
	\paragraph{Node.js}\mbox{} \\ \mbox{} \\
	Utilizzato per creare applicazioni di rete scalabili non solo lato client ma anche lato server.
	\\
	\centerline{\url{https://nodejs.org/it/about/}}
	\paragraph{NPM}\mbox{} \\ \mbox{} \\
	Utilizzato per poter installare i pacchetti necessari allo sviluppo dell’applicativo (React\glo).
	\\
	\centerline{\url{https://www.npmjs.com/}}
	\paragraph{React}\mbox{} \\ \mbox{} \\
	Per la realizzazione dell’interfaccia utente a livello di applicazione web.\\
	\centerline{\url{https://reactjs.org/}}
	\paragraph{TravisCI}\mbox{} \\ \mbox{} \\
	Impiegato per garantire la continuous integration.
	\\
	\centerline{\url{https://travis-ci.org/}}
	\subsection{Procedure}
	\subsubsection{Draw.io}
	\paragraph*{Creazione dei diagrammi UML} \mbox{} \\ \mbox{} \\
	Per la creazione dei diagrammi UML è necessario accedere a Google Drive con le credenziali del gruppo, entrare nella cartella \texttt{Analisi\_dei\_requisiti/img/Diagrammi\_UML}. \\ Un diagramma UML deve essere creato rispettando il seguente ordine: \begin{itemize}
\item nel menù \texttt{New}, scegliere \texttt{More} e quindi fare click su \texttt{draw.io Diagrams};
\item realizzare il diagramma;
\item nel menù \texttt{File}, scegliere \texttt{Export as..} e selezionare \texttt{PNG};
\item inserire un nome esplicativo, indicando il codice del caso d'uso di riferimento e un breve titolo;
\item alla richiesta di selezionare in quale cartella salvare il diagramma in formato PNG selezionare \texttt{No, pic folder..} e assicurarsi di salvare nella cartella apposita denominata \texttt{Diagrammi\_UML}.
\end{itemize}

	\subsubsection{NPM}
	\paragraph*{Installazione di un pacchetto} \mbox{} \\ \mbox{} \\
	Per poter installare un pacchetto Node all'interno dell'ambiente di sviluppo IntelliJ, bisogna utilizzare il seguente comando:\\
	\centerline{\texttt{npm install <nome\_pacchetto>}}
	Successivamente, provvederà direttamente IntelliJ a scaricare ed importare nel progetto il pacchetto desiderato.
	
	\paragraph*{Avvio del server} \mbox{} \\ \mbox{} \\
	Per avviare il \texttt{server node.js}, bisogna utilizzare il comando \texttt{npm start}.\\
	Viceversa, per bloccare la sua esecuzione, utilizzare il comando \texttt{npm stop}.

	\subsubsection{InfluxDB}
	Innanzittutto è necessario scaricare l'eseguibile per poter avviare il server.
    Quest'ultimo lo si può scaricare dal seguente link:\\
	\centerline{\url{https://portal.influxdata.com/downloads/}.} 
    
	\paragraph*{Avvio del server} \mbox{} \\ \mbox{} \\
	Per avviare il server di InfluxDB, eseguire \texttt{influxd.exe}. \\
	Per avviare la CLI, eseguire \texttt{influx.exe}.